#version 300 es
/* Copyright 2015 Richard Sahlin
 *
 * Fragment shader for glTF asset
 * @author Richard Sahlin
 */
precision mediump float;

//F0, 1 - F0, Cdiff, metallic, roughness, roughness ^2
uniform vec4 _PBRDATA[4];
uniform vec3 _LIGHT_0[1];
const float pi = 3.141592;
const float oneByPI = 1 / pi;
const float twoByPI = 2 / pi;

in vec3 vNormal;
in vec3 vEye;
in vec3 vLight;

out vec4 fragColor;

void main()
{
    vec3 F0 = vec3(_PBRDATA[0]);
    vec3 diffuse = vec3(_PBRDATA[2]);
    vec3 oneMinusF0 = vec3(_PBRDATA[1]);
//    vec3 H = normalize(vLight + vEye);
    vec3 lightOut = reflect(vLight, vNormal);
    vec3 u = lightOut + vLight;
    //u = (Bisect vector of (outcoming direction of light, Incoming direction of light) 
    //F(u) = F + (1 - F) (1 - u) ^ 5
    vec3 fresnel = oneMinusF0 * pow(1.0 - dot(vEye,u),5.0);
    float alpha = _PBRDATA[3].z;
    float a2 = alpha * alpha;
    float distribution = (a2) / (3.14159 * pow( (pow( dot( vNormal, u),2) * (a2 - 1) + 1),2) );
    float k = _PBRDATA[3].y * sqrt(twoByPI);
    float vDotH = dot(lightOut, u);
    float attenuation = vDotH / (vDotH * (1 - k) + k);
    //specular = (Fresnel * Geometric occlusion * Distribution) / ( 4 * (N dot L) * (N dot V)
    vec3 specular = (fresnel) / (4 * dot(vNormal,vLight) * dot(vNormal, vEye));
    fragColor = vec4((oneMinusF0 * diffuse) + fresnel, _PBRDATA[0].a);
}

