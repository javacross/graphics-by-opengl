#version 300 es
/* 
 *
 * Fragment shader for glTF asset
 * @author Richard Sahlin
 */
precision mediump float;

uniform lowp sampler2D uTexture; //The texture sampler
uniform vec4 _PBRDATA[2];
uniform vec3 _LIGHT_0[1];
const vec3 dieletricSpecular = vec3(0.04, 0.04, 0.04);
const vec3 black = vec3(0.0, 0.0, 0.0);
const float pi = 3.141592;
const float oneByPI = 1 / pi;
const float twoByPI = 2 / pi;

in vec2 vTexCoord0;
in vec3 vNormal;
in vec3 vEye;
in vec3 vLight;

out vec4 fragColor;

float lerp(float a, float b, float w);
vec3 lerp3(vec3 a, vec3 b, float w);


void main()
{
    vec3 F0 = vec3(lerp3(dieletricSpecular, _PBRDATA[0].rgb, _PBRDATA[1].x));
    vec3 diffuse = vec3(lerp3(_PBRDATA[0].rgb * (1.0 - 0.04), black, _PBRDATA[1].x) * oneByPI);
    vec3 oneMinusF0 = (1.0 - F0);
    vec3 h = normalize(vLight + vEye);
    //F(u) = F + (1 - F) (1 - (dot(Bisector,Outcoming light)
    vec3 fresnel = F0 + oneMinusF0 * pow(1.0 - dot(vEye,h),5.0);
    float alpha = _PBRDATA[1].y * _PBRDATA[1].y;
    float a2 = alpha * alpha;
    float distribution = (a2) / (3.14159 * pow( (pow( dot( vNormal, h),2) * (a2 - 1) + 1),2) );
//    float k = _PBRDATA[1].y * sqrt(twoByPI);
    vec3 specular = (fresnel + distribution) / (4 * dot(vNormal,vLight) * dot(vNormal, vEye));
    fragColor = texture(uTexture, vTexCoord0) * vec4((oneMinusF0 * diffuse) + specular, _PBRDATA[0].a);
}

float lerp(float a, float b, float w) {
  return a + w*(b-a);
}
vec3 lerp3(vec3 a, vec3 b, float w) {
  return a + w*(b-a);
}
