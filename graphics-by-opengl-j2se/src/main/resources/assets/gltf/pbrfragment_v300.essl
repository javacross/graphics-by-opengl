#version 300 es
/**
 * Functions for gltf PBR model
 */
precision highp float;

uniform mediump sampler2D uTexture0; //The texture 0 sampler
uniform highp sampler2D uTextureNormal; //normal texture sampler
uniform mediump sampler2D uTextureMR; //Metallic roughness texture sampler

//Metallic,roughnessfactor [2]
//F0         [3] - dielectricSpecular -> basecolor for metallic = 1
//cDiff      [3]
//diffuse    [4]
//k, alpha ^ 2, exposure, gamma
uniform vec4 _PBRDATA[5];
//RGB + Intensity
//XYZ
uniform vec4 _LIGHT_0[2];

const float pi = 3.141592;
const float sqrtTwoByPi = sqrt(2.0 / pi);
const float oneByPI = 1.0 / pi;
const float twoByPI = 2.0 / pi;
const float gamma = 2.2;
const float oneByGamma = 1.0 / gamma;
const vec3 dielectricSpecular = vec3(0.04, 0.04, 0.04);
const vec3 black = vec3(0.0, 0.0, 0.0);

in vec2 vTexCoord0;
in vec2 vTexNormal;
in vec2 vTexMR;
in vec3 vNormal;
in vec3 vEye;
in vec3 vLight;
in mat3 mTangentLight;

out vec4 fragColor;

/**
 * Takes the incoming pbr calculated pixel, applies exposure and gamma correction then writes to fragColor
 * using the alpha from the materials diffuse color.
 * @param pbr The pbr calculated pixel - including alpha from texture if used.
 */
void outputPixel(vec4 pbr) {
    vec3 hdrExposure = vec3(1.0) - exp(-(pbr.rgb) * _PBRDATA[4].z);
    fragColor = vec4(pow(hdrExposure, vec3(_PBRDATA[4].w)), _PBRDATA[3].a); 
}
/**
 * cdiff = lerp(baseColor.rgb * (1 - dielectricSpecular.r), black, metallic) 
 * F0 = lerp(dielectricSpecular, baseColor.rgb, metallic) 
 * α = roughness ^ 2
 * F = F0 + (1 - F0) * (1.0 - V * H)^5
 * diffuse = (1 - F) * cdiff
 */
vec3 internalCalculatePBR(vec3 normal, vec3 F0, vec3 cDiff, float a2, float k) {
    //vec3 lightOut = reflect(vLight, normal);
    //u = (Bisect vector of (outcoming direction of light, Incoming direction of light) 
    //F(u) = F + (1 - F) (1 - u) ^ 5
    vec3 H = normalize((vLight + vEye));
    vec3 fresnel = F0 + (1.0 - F0) * pow(1.0 - dot(vEye, H), 5.0);
    vec3 diffuse = ((1.0 - fresnel) * (cDiff * _LIGHT_0[0].rgb * _LIGHT_0[0].a) * dot(normal,vLight));
    float distPow = pow(dot(normal, H),2.0);
//    float distribution = clamp((a2) / (pi * pow((distPow * (a2 - 1.0) + 1.0),2.0)), 0.0, 1.0);
    float distribution = (a2) / (pi * pow((distPow * (a2 - 1.0) + 1.0),2.0));
    //Do not include negative angles in occlusion
    float LDotH = dot(vLight, H);
    float GL = clamp(LDotH / (LDotH * (1.0 - k) + k), 0.0, 1.0);
//    float GL = LDotH / (LDotH * (1.0 - k) + k);
    float NDotH = dot(normal, H);
    float GN = clamp(NDotH /(NDotH * (1.0 - k) + k), 0.0, 1.0);
//    float GN = NDotH /(NDotH * (1.0 - k) + k);
//    vec3 specular = max(vec3(0.0,0.0,0.0), ((fresnel * _LIGHT_0[0].rgb * _LIGHT_0[0].a) * (GL * GN * distribution))); // / (4.0 * (dot(normal, vLight) * (dot(normal, vEye)))));
    vec3 specular = (fresnel * GL * GN * distribution);// / max(0.001, (4.0 * (dot(normal, vLight) * (dot(normal, vEye)))));
    return diffuse;
}

vec3 calculateFresnelDiffuse(vec3 normal) {
    return internalCalculatePBR(normal, _PBRDATA[1].rgb, _PBRDATA[2].rgb, _PBRDATA[4].y, _PBRDATA[4].x);
}

/**
 * cdiff = lerp(baseColor.rgb * (1 - dielectricSpecular.r), black, metallic) 
 * F0 = lerp(dielectricSpecular, baseColor.rgb, metallic) 
 * α = roughness ^ 2
 * F = F0 + (1 - F0) * (1.0 - V * H)^5
 */
vec3 calculateFresnelDiffuse(vec3 normal, vec3 metallicRoughness) {
    float roughness = _PBRDATA[0].y * metallicRoughness.g;
    float a2 = pow(roughness, 4.0);
    float k = roughness * sqrtTwoByPi;
    float metal =  _PBRDATA[0].x * metallicRoughness.b;
    vec3 F0 = mix(dielectricSpecular, _PBRDATA[3].rgb, metal);
    return internalCalculatePBR(normal, F0, mix(_PBRDATA[3].rgb, vec3(0.0,0.0,0.0), metal), a2, k);
}



