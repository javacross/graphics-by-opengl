#version 300 es
/**
 * Functions for gltf PBR model
 */
precision highp float;

uniform lowp sampler2D uTexture0; //The texture 0 sampler
uniform lowp sampler2D uTextureNormal; //normal texture sampler
//properties [4]
//F0         [3]
//1 - F0     [3]
//diffuse    [3]
// metallic, k, alpha ^ 2
uniform vec4 _PBRDATA[5];
uniform vec3 _LIGHT_0[1];
const float pi = 3.141592;
const float oneByPI = 1.0 / pi;
const float twoByPI = 2.0 / pi;

in vec2 vTexCoord0;
in vec2 vTexNormal;
in vec3 vNormal;
in vec3 vEye;
in vec3 vLight;
in mat3 mTangentLight;

out vec4 fragColor;


vec4 calculateFresnelDiffuse() {
    vec3 H = normalize((vLight + vEye));
    //vec3 lightOut = reflect(vLight, vNormal);
    //u = (Bisect vector of (outcoming direction of light, Incoming direction of light) 
    //F(u) = F + (1 - F) (1 - u) ^ 5
    vec3 fresnel = _PBRDATA[1].rgb + _PBRDATA[2].rgb * pow(1.0 - dot(vEye,H),5.0);
    vec3 diffuse = ((1.0 - fresnel) * _PBRDATA[3].rgb) * dot(vNormal,vLight);
    float a2 = _PBRDATA[4].z;
    float distPow = pow(dot(vNormal, H),2.0);
    float distribution = (a2) / (pi * pow((distPow * (a2 - 1.0) + 1.0),2.0));
    const float k = _PBRDATA[4].y;
    float LDotH = dot(vLight, H);
    float GL = LDotH / (LDotH * (1.0 - k) + k);
    float NDotH = dot(vNormal, H);
    float GN = NDotH /(NDotH * (1.0 - k) + k);
    vec3 specular = max(vec3(0.0,0.0,0.0), (fresnel * (GL * GN) * distribution));// / max(1.0,(4.0 * (dot(vNormal, vLight) * (dot(vNormal, vEye))))));
    return vec4(diffuse + specular, _PBRDATA[1].a);
}

vec4 calculateFresnelDiffuseTexNormal() {
    vec3 H = normalize((vLight + vEye));
    //u = (Bisect vector of (outcoming direction of light, Incoming direction of light) 
    //F(u) = F + (1 - F) (1 - u) ^ 5
    vec3 fresnel = _PBRDATA[1].rgb + _PBRDATA[2].rgb * pow(1.0 - dot(vEye,H),5.0);
    vec3 normal = normalize((vec3(texture(uTextureNormal, vTexNormal)) * mTangentLight));
    vec3 diffuse = ((1.0 - fresnel) * _PBRDATA[3].rgb) * dot(normal,vLight);
    float a2 = _PBRDATA[4].z;
    float distPow = pow(dot(normal, H),2.0);
    float distribution = (a2) / (pi * pow((distPow * (a2 - 1.0) + 1.0),2.0));
    const float k = _PBRDATA[4].y;
    float LDotH = dot(vLight, H);
    float GL = LDotH / (LDotH * (1.0 - k) + k);
    float NDotH = dot(normal, H);
    float GN = NDotH /(NDotH * (1.0 - k) + k);
    vec3 specular = max(vec3(0.0,0.0,0.0), (fresnel * (GL * GN) * distribution));// / max(1.0,(4.0 * (dot(normal, vLight) * (dot(normal, vEye))))));
    return vec4(diffuse + specular, _PBRDATA[1].a);
}



