#version 300 es
/**
 * Functions for gltf PBR model
 */
precision highp float;

uniform lowp sampler2D uTexture; //The texture sampler
//properties, F0, 1 - F0, diffuse, metallic, roughness, roughness ^2
uniform vec4 _PBRDATA[5];
uniform vec3 _LIGHT_0[1];
const float pi = 3.141592;
const float oneByPI = 1.0 / pi;
const float twoByPI = 2.0 / pi;

in vec2 vTexCoord0;
in vec3 vNormal;
in vec3 vEye;
in vec3 vLight;

out vec4 fragColor;


vec4 calculateFresnelDiffuse() {
    vec3 H = normalize((vLight + vEye));
    //u = (Bisect vector of (outcoming direction of light, Incoming direction of light) 
    //F(u) = F + (1 - F) (1 - u) ^ 5
    vec3 fresnel = _PBRDATA[1].rgb + _PBRDATA[2].rgb * pow(1.0 - dot(vEye,H),5.0);
    vec3 diffuse = ((1.0 - fresnel) * _PBRDATA[3].rgb) * dot(vNormal,vLight);
    float alpha = _PBRDATA[4].z;
    float a2 = alpha * alpha;
    float distPow = pow(dot(vNormal, H),2.0);
    float distribution = (a2) / (pi * pow((distPow * (a2 - 1.0) + 1.0),2.0));
    float k = _PBRDATA[4].y * sqrt(twoByPI);
    float LDotH = dot(vLight, H);
    float GL = LDotH / (LDotH * (1.0 - k) + k);
    float NDotH = dot(vNormal, H);
    float GN = NDotH /(NDotH * (1.0 - k) + k);
    vec3 specular = max(vec3(0.0,0.0,0.0), (fresnel * (GL * GN) * distribution) / ( 4.0 * (dot(vNormal, vLight) * (dot(vNormal, vEye)))));
    return vec4(diffuse + specular, _PBRDATA[1].a);
}

