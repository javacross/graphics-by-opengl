#version 300 es
/**
 * Functions for gltf PBR model
 */
precision highp float;

vec4 calculateFresnelDiffuse() {
    vec3 H = normalize((vLight + vEye));
//    vec3 lightOut = reflect(vLight, vNormal);
//    vec3 u = lightOut + vLight;
    //u = (Bisect vector of (outcoming direction of light, Incoming direction of light) 
    //F(u) = F + (1 - F) (1 - u) ^ 5
    vec3 fresnel = _PBRDATA[0].rgb + _PBRDATA[1].rgb * pow(1.0 - dot(vEye,vU),5.0);
    vec3 diffuse = (1.0 - fresnel) * _PBRDATA[2].rgb;
    float alpha = _PBRDATA[3].z;
    float a2 = alpha * alpha;
    float distribution = (a2) / (pi * pow( (pow( dot( vNormal, H),2) * (a2 - 1) + 1),2) );
    float k = _PBRDATA[3].y * sqrt(twoByPI);
    float vDotH = dot(vLight, vEye);
    float attenuation = vDotH / (vDotH * (1 - k) + k);
    //specular = (Fresnel * Geometric occlusion * Distribution) / ( 4 * (N dot L) * (N dot V)
//    vec3 specular = max(vec3(0.0,0.0,0.0), (fresnel * distribution));// / (4 * dot(vNormal,vLight) * dot(vNormal, vEye)));
    vec3 specular = (max(vec3(0.0,0.0,0.0), fresnel) * distribution);
    return vec4(specular + diffuse, _PBRDATA[0].a);
}

