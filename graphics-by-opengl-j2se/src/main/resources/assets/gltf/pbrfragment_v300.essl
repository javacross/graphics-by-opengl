#version 300 es
/**
 * Functions for gltf PBR model
 */ 
precision highp float;

uniform mediump sampler2D uTexture0; //The texture 0 sampler
uniform highp sampler2D uTextureNormal; //normal texture sampler
uniform mediump sampler2D uTextureMR; //Metallic roughness texture sampler

//Metallic,roughnessfactor, exposure, gamma
//F0         [3] - dielectricSpecular -> basecolor for metallic = 1
//cDiff      [3]
//diffuse    [4]
uniform vec4 _PBRDATA[4];

in vec2 vTexCoord0;
in vec2 vTexNormal;
in vec2 vTexMR;
in vec4 vWorldPos;
in mat3 mTangentLight;
in Material material;
in Light light;

out vec4 fragColor;

/**
 * Takes the incoming pbr calculated pixel, applies exposure and gamma correction then writes to fragColor
 * using the alpha from the materials diffuse color.
 * @param pbr The pbr calculated pixel - including alpha from texture if used.
 */
void outputPixel(vec4 pbr) {
    vec3 hdrExposure = vec3(1.0) - exp(-(pbr.rgb) * _PBRDATA[0].z);
    fragColor = vec4(pow(hdrExposure, vec3(_PBRDATA[0].w)), _PBRDATA[3].a); 
}

vec3 F_Schlick(const vec3 F0, const BRDF brdf) {
    return F0 + (1.0 - F0) * pow(1.0 - material.VdotH, 5.0);
}

float V_SmithGGXCorrelated(const float linearRoughness, const BRDF brdf) {
    // Heitz 2014, "Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs"
    float a2 = linearRoughness * linearRoughness;
    // TODO: lambdaV can be pre-computed for all the lights, it should be moved out of this function
    float lambdaV = material.NdotL * sqrt((material.NdotV - a2 * material.NdotV) * material.NdotV + a2);
    float lambdaL = material.NdotV * sqrt((material.NdotL - a2 * material.NdotL) * material.NdotL + a2);
    float v = 0.5 / (lambdaV + lambdaL);
    // a2=0 => v = 1 / 4*NoL*NoV   => min=1/4, max=+inf
    // a2=1 => v = 1 / 2*(NoL+NoV) => min=1/4, max=+inf
    // clamp to the maximum value representable in mediump
    return clamp(v, 0.0, 1.0);
}


float D_GGX(const float linearRoughness, const BRDF brdf) {
    vec3 NxH = cross(brdf.normal, material.H);
    float a = material.NdotH * linearRoughness;
    float k = linearRoughness / (dot(NxH, NxH) + a * a);
    float d = k * k * (1.0 / pi);
    return max(d, 0.0);
}

float D_GLTF(float roughness, const BRDF brdf) {
    vec3 NxH = cross(brdf.normal, material.H);
    float a = roughness * roughness;
    float a2 = a * a;
    float distPow = 1.0 - dot(NxH, NxH);
    //Use distPow to add tint
    return ((a2) / (pi * pow((distPow * (a2 - 1.0) + 1.0),2.0)));
}

float V_GLTF(const float roughness, const BRDF brdf) {
    float k = roughness * sqrtTwoByPi;
    float GL = clamp(material.LdotH / (material.LdotH * (1.0 - k) + k), 0.0, 1.0);
    float GN = clamp(material.NdotH /(material.NdotH * (1.0 - k) + k), 0.0, 1.0);
    return (GL * GN) / max(1.0, 4 * material.NdotL * material.NdotV);
}

vec3 Diffuse_GLTF(vec3 fresnel, vec3 cDiff) {
    return (1.0 - fresnel) * cDiff;
}


/**
 * cdiff = lerp(baseColor.rgb * (1 - dielectricSpecular.r), black, metallic) 
 * F0 = lerp(dielectricSpecular, baseColor.rgb, metallic) 
 * α = roughness ^ 2
 * F = F0 + (1 - F0) * (1.0 - V * H)^5
 * diffuse = (1 - F) * cdiff
 */
vec3[2] internalCalculatePBR(const BRDF brdf, const vec3 F0, const vec3 cDiff, const float roughness) {
    float a = roughness * roughness;
    vec3 fresnel = F_Schlick(F0, brdf);
    float distPow;
    float NDF = D_GLTF(roughness, brdf);
    float V = V_GLTF(roughness, brdf);
    vec3[2] result;
//    vec3 tint = mix(_PBRDATA[3].rgb, light.color.rgb, NdotH);
    vec3 specular = fresnel * NDF * V;
    vec3 diffuse = (1.0 - fresnel) * (cDiff * oneByPI);
    vec3 illumination = light.color.rgb * (light.color.a * material.NdotL);
//    result[0] = (diffuse + specular * mix(_PBRDATA[3].rgb, dielectricSpecular, 1 - distPow)) * illumination;
//    result[1] = (specular * mix(dielectricSpecular, light.color.rgb, 1 - distPow)) * illumination;
    result[0] = (diffuse + specular) * illumination;
    result[1] = vec3(0.0,0.0,0.0);
    return result;
    
}

vec3[2] calculateFresnelDiffuse(const BRDF brdf) {
    return internalCalculatePBR(brdf, _PBRDATA[1].rgb, _PBRDATA[2].rgb, max(MIN_ROUGHNESS, _PBRDATA[0].y));
}

/**
 * cdiff = lerp(baseColor.rgb * (1 - dielectricSpecular.r), black, metallic) 
 * F0 = lerp(dielectricSpecular, baseColor.rgb, metallic) 
 * α = roughness ^ 2
 * F = F0 + (1 - F0) * (1.0 - V * H)^5
 */
vec3[2] calculateFresnelDiffuse(const BRDF brdf, const vec3 metallicRoughness) {
    float roughness = max(MIN_ROUGHNESS,_PBRDATA[0].y * metallicRoughness.g);
    float metal =  clamp(_PBRDATA[0].x * metallicRoughness.b, MIN_METALLIC, MAX_METALLIC);
    vec3 F0 = mix(dielectricSpecular, _PBRDATA[3].rgb, metal);
    return internalCalculatePBR(brdf, F0, mix(_PBRDATA[3].rgb, dielectricSpecular, metal), roughness);
}

